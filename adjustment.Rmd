---
title: "Forecasting proportions of total employment"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(here)
library(vroom)
library(plotly)
library(shiny)
library(conflicted)
conflicts_prefer(vroom::cols)
conflicts_prefer(vroom::col_double)
conflicts_prefer(vroom::col_character)
conflicts_prefer(dplyr::filter)
cagr_horizon <- 10
#functions--------------------------------------
margin_plot <- function(tbbl, margin){
  plt <- tbbl|>
  ggplot()+
    geom_line(aes(year, 
                  employment, 
                  colour=series, 
                  lty=series,
                  group=series,
                  text=paste0(
                    description,
                    "\n Employment: ",
                    scales::comma(employment, accuracy = 1),
                    "\n Year: ",
                    year,
                    "\n Modified 10 year CAGR: ",
                    mod_cagr,
                    "\n Pre modification 10 year CAGR: ",
                    pre_cagr,
                    "\n 10 year historic CAGR: ",
                    historic_cagr
                    )))+
    facet_wrap(~ get(margin), scales = "free_y")+
    labs(x=NULL,
         y=NULL)+
    theme_minimal()+
    theme(text=element_text(size=13),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())
  ggplotly(plt, tooltip = "text")
}
get_total <- function(tbbl){
   sum(tbbl$employment)
 } 
get_cagr <- function(tbbl, horizon){
  max_year <- max(tbbl$year)
  start <- tbbl$employment[tbbl$year==max_year-horizon]
  end <-  tbbl$employment[tbbl$year==max_year]
  if_else(start==0, 1, (end/start)^(1/horizon)) #if start=0 the data is probably shitty: assume zero growth
}
occ_plot <- function(pg){
  plt <- bind_rows(occupation_historic, post_mod_occupation(), pre_mod_occupation())|>
    filter(page==pg)|>
    left_join(noc_descriptions)|>
    left_join(occupation_pre_cagrs()|>mutate(pre_cagr=scales::percent(pre_cagr, accuracy=.1)))|>
    left_join(occupation_mod_cagrs()|>mutate(mod_cagr=scales::percent(mod_cagr, accuracy=.1)))|>
    left_join(occupation_historic_cagrs|>mutate(historic_cagr=scales::percent(historic_cagr, accuracy=.1)))|>
    ggplot()+
      geom_line(aes(year, 
                    employment, 
                    colour=series, 
                    lty=series,
                    group=series,
                    text=paste0(class_title,
                                "\n Employment: ",
                                scales::comma(employment, accuracy = 1),
                                "\n Year: ",
                                year,
                                "\n Modified 10 year CAGR: ",
                                mod_cagr,
                                "\n Pre modification 10 year CAGR: ",
                                pre_cagr,
                                "\n 10 year historic CAGR: ",
                                historic_cagr)
                    )
                )+
      facet_wrap(~noc_5, scales = "free_y")+
      labs(x=NULL,
           y=NULL)+
      theme_minimal()+
      theme(text=element_text(size=13),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank())
  ggplotly(plt, tooltip = "text")
}

# read in the data----------------------------
noc_descriptions <- vroom(here("data", "mapping","noc21descriptions.csv"), 
                          col_types = cols(noc_5 = col_character(), class_title = col_character()),
                          delim=",")|>
  mutate(noc_5=str_pad(noc_5, width=5, pad="0"))

region_historic <- read_rds(here("out","historic_bc_region.rds"))
industry_historic <- read_rds(here("out", "historic_lmo_ind_code.rds"))
occupation_historic <- read_rds(here("out","historic_noc_5.rds"))|>
  full_join(noc_descriptions)|>
  arrange(noc_5)|>
  mutate(page=ntile(n=12))|>
  group_by(page)|>
  mutate(page_description=paste0(min(noc_5),"-",max(noc_5)))
noc_pages <- occupation_historic|> #by NOC aggregates need to be split across multiple pages.
  select(noc_5, class_title, page)|>
  distinct()
mod_shares <-  read_rds(here("out","modified_shares","shares.rds")) #forecast shares, overwritten on each save
bc_fcast <- read_rds(here("out","bc_forecast.rds")) #the BC finance forecast plus ETS forecast for last 6 years.
regions <- unique(region_historic$bc_region)
industries <- unique(industry_historic$lmo_ind_code)
occupations <- unique(occupation_historic$noc_5)
#non-reactive growth rates
regional_historic_cagrs <- region_historic|>
  group_by(bc_region)|>
  nest()|>
  mutate(historic_cagr=map_dbl(data, get_cagr, cagr_horizon),
         historic_cagr=historic_cagr-1)|>
  select(-data)

industry_historic_cagrs <- industry_historic|>
  group_by(lmo_ind_code)|>
  nest()|>
  mutate(historic_cagr=map_dbl(data, get_cagr, cagr_horizon),
         historic_cagr=historic_cagr-1)|>
  select(-data)

occupation_historic_cagrs <- occupation_historic|>
  group_by(noc_5)|>
  nest()|>
  mutate(historic_cagr=map_dbl(data, get_cagr, cagr_horizon),
         historic_cagr=historic_cagr-1)|>
  select(-data)
```

Inputs {.sidebar}
=====================================


```{r}
# shiny inputs defined here
selectInput(
  "margin",
  "What margin do you want to manipulate?",
  c("bc_region", "noc_5", "lmo_ind_code"),
  "bc_region"
)
```

```{r}

dropdown <- reactive({
  if(input$margin=="bc_region"){
    regions
  }else if(input$margin=="noc_5"){
    occupations
  }else if(input$margin=="lmo_ind_code"){
    industries
  }else{
    stop("Error: select margin")
  }
})

renderUI({#need the renderUI because dropdown list is a reactive object
  selectInput('item', 
              'What item do you want to manipulate?', 
              dropdown()
              )
})

sliderInput("shift", "Shift up or down",
  min = .7, max = 1.3,
  value = 1, step = .01
)
sliderInput("slope", "Change slope",
  min = .95, max = 1.03,
  value = 1, step = .001
)
actionButton("save", "Save modified shares to disk")
```
 
```{r}
#reactive elements
shares <- reactive({#the shares after the current modification (slope and shift)
  mod_shares|>
      ungroup()|>
      mutate(multiplier=if_else(get(input$margin) == input$item, 
                                input$shift*input$slope^(year-min(year)), 
                                1))|>
    group_by(year)|>
    mutate(post_mod_share=pre_mod_share*multiplier,
           post_mod_share=post_mod_share/sum(post_mod_share)) #proportions must sum to 1
})
# the cell forecasts pre and post modification
pre_mod_forecast <- reactive({
 inner_join(shares(), bc_fcast)|>
    mutate(employment=pre_mod_share*employment,
           series="Pre modification")
})
post_mod_forecast <- reactive({
  inner_join(shares(), bc_fcast)|>
    mutate(employment=post_mod_share*employment,
           series="Post modification")
})
# regional aggregates of the pre and post modification forecasts
pre_mod_region <- reactive({
  pre_mod_forecast()|>
    group_by(year, bc_region, series)|>
    summarize(employment=sum(employment))
})
post_mod_region <- reactive({
  post_mod_forecast()|>
    group_by(year, bc_region, series)|>
    summarize(employment=sum(employment))
})
# industry aggregates of the pre and post modification forecasts
pre_mod_industry <- reactive({
  pre_mod_forecast()|>
    group_by(year, lmo_ind_code, lmo_detailed_industry, series)|>
    summarize(employment=sum(employment))
})
post_mod_industry <- reactive({
  post_mod_forecast()|>
    group_by(year, lmo_ind_code, lmo_detailed_industry, series)|>
    summarize(employment=sum(employment))
})
# occupation aggregates of the pre and post modification forecasts
pre_mod_occupation <- reactive({
  pre_mod_forecast()|>
    group_by(year, noc_5, series)|>
    summarize(employment=sum(employment))|>
    full_join(noc_pages)
})
post_mod_occupation <- reactive({
  post_mod_forecast()|>
    group_by(year, noc_5, series)|>
    summarize(employment=sum(employment))|>
    full_join(noc_pages)
})
# the CAGRs of the modified aggregate forecasts
regional_mod_cagrs <- reactive({
  post_mod_region()|>
    group_by(bc_region)|>
    nest()|>
    mutate(mod_cagr=map_dbl(data, get_cagr, 10),
           mod_cagr=mod_cagr-1)|>
    select(bc_region, mod_cagr)
})
industry_mod_cagrs <- reactive({
  post_mod_industry()|>
    group_by(lmo_ind_code)|>
    nest()|>
    mutate(mod_cagr=map_dbl(data, get_cagr, 10), 
           mod_cagr=mod_cagr-1)|>
    select(lmo_ind_code, mod_cagr)
})
occupation_mod_cagrs <- reactive({
  post_mod_occupation()|>
    group_by(noc_5)|>
    nest()|>
    mutate(mod_cagr=map_dbl(data, get_cagr, 10), 
           mod_cagr=mod_cagr-1)|>
    select(noc_5, mod_cagr)      
})
# the CAGRs of the pre modification aggregate forecasts
regional_pre_cagrs <- reactive({
  pre_mod_region()|>
    group_by(bc_region)|>
    nest()|>
    mutate(pre_cagr=map_dbl(data, get_cagr, 10),
           pre_cagr=pre_cagr-1)|>
    select(bc_region, pre_cagr)
})
industry_pre_cagrs <- reactive({
  pre_mod_industry()|>
    group_by(lmo_ind_code)|>
    nest()|>
    mutate(pre_cagr=map_dbl(data, get_cagr, 10), 
           pre_cagr=pre_cagr-1)|>
    select(lmo_ind_code, pre_cagr)
})
occupation_pre_cagrs <- reactive({
  pre_mod_occupation()|>
    group_by(noc_5)|>
    nest()|>
    mutate(pre_cagr=map_dbl(data, get_cagr, 10), 
           pre_cagr=pre_cagr-1)|>
    select(noc_5, pre_cagr)      
})
#writing the modified proportions to disk
observeEvent(input$save, {
  shares()|> #give the modified share tbbl same structure as pre_mod_share tbbl, and overwrite.
    select(-pre_mod_share, -multiplier)|>
    rename(pre_mod_share=post_mod_share)|>
    write_rds(here("out","modified_shares", "shares.rds"))
  tibble("margin"=input$margin, 
         "item"=input$item, 
         "shift"=input$shift, 
         "slope"=input$slope)|>
    write.table(here("out","change_log", "changes.csv"),
    append = TRUE,
    quote = TRUE,
    sep = ",",
    row.names = FALSE,
    col.names = !file.exists(here("out","change_log", "changes.csv"))
  )
})
```

Description
=====================================

### Intro

* For the BC LMO we are constrained by the Finance BC employment forecast (at least for the first 5 years)
* Given this constraint, in effect we are forecasting proportions of BC employment.
* There are 4 dimensions that we care about: Time, Region, Industry and Occupation.
* At a given point in time, one can visualize the remaining 3 dimensions as a cube, with sides representing the 7 regions, 64 industries, and 517 occupations, and cells representing the proportion of BC employment for that combination of region, industry and occupation.
* Note that this cube is extremely sparse: there are not many combinations of region, industry and occupation that have positive proportions.
* We are typically interested in looking at two dimensions at a time: e.g. industry employment over time, aggregating over the remaining two dimensions. 
* Our forecasting technique needs to overcome the limitations associated with the sparsity of the data.

### Approach taken:

*  Using LFS data from the years 2018,2019,2021,2022,2023 we calculate baseline proportions of BC employment based on every combination of region, industry and occupation.
*  We then aggregate the data by each of the above margins, and calculate the 5 year CAGR (2018--2023) for each item of each margin e.g. the recent historic growth rate for the Kootenays.
*  We then apply these marginal growth rates to adjust the baseline proportions.
*  For example, suppose that a region/industry/occupation combination accounted for 1% of the BC labour market over the years 2018,2019,2021,2022,2023.  Suppose that region's CAGR is 2%, the industry's CAGR is 3%, and the occupation's CAGR is -4%,
*  For the $t$th year of the forecast, the unadjusted proportion is $.01\times1.02^{t}\times1.03^{t}\times.96^{t}$.
*  Note that regarding the *change* in proportions over time, region, industry and occupation are assumed to be independent.
*  This is in contrast to the baseline levels, where the sparsity of the data indicates strong dependency between region, industry and occupation.
*  Note that these unadjusted proportions will not necessarily sum to 1: we adjust so they do so.

BC timeplot
====================================

```{r}
ggplot(bc_fcast, aes(year, employment, colour=series))+
  geom_line()+
  theme_minimal()+
  scale_y_continuous(labels = scales::comma)+
  labs(x=NULL, y=NULL, colour=NULL)
```



   
Region timeplots
====================================     

### Regional Employment

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
  bind_rows(region_historic, post_mod_region(), pre_mod_region())|>
    mutate(description=bc_region)|>
    full_join(regional_mod_cagrs()|>mutate(mod_cagr=scales::percent(mod_cagr, accuracy=.1)))|>
    full_join(regional_pre_cagrs()|>mutate(pre_cagr=scales::percent(pre_cagr, accuracy=.1)))|>
    full_join(regional_historic_cagrs|>mutate(historic_cagr=scales::percent(historic_cagr, accuracy=.1)))|>
    margin_plot("bc_region")
})
```

Industry timeplots
=====================================  

### Industry Employment
 
```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
  bind_rows(industry_historic, post_mod_industry(), pre_mod_industry())|>
    rename(description=lmo_detailed_industry)|>
    full_join(industry_mod_cagrs()|>mutate(mod_cagr=scales::percent(mod_cagr, accuracy=.1)))|>
    full_join(industry_pre_cagrs()|>mutate(pre_cagr=scales::percent(pre_cagr, accuracy=.1)))|>
    full_join(industry_historic_cagrs|>mutate(historic_cagr=scales::percent(historic_cagr, accuracy=.1)))|>
    margin_plot("lmo_ind_code")
})
``` 

Occupation timeplots
=====================================
 
 Row {.tabset}
-------------------------------------
   
### `r unique(occupation_historic$page_description[occupation_historic$page==1])`
    
```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(1)
})
``` 

### `r unique(occupation_historic$page_description[occupation_historic$page==2])`
 
```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(2)
})
``` 
 
### `r unique(occupation_historic$page_description[occupation_historic$page==3])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(3)
})
```  

### `r unique(occupation_historic$page_description[occupation_historic$page==4])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(4)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==5])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(5)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==6])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(6)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==7])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(7)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==8])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(8)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==9])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(9)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==10])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(10)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==11])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(11)
})
```

### `r unique(occupation_historic$page_description[occupation_historic$page==12])`

```{r, fig.retina=2}
renderPlotly({
  req(input$margin)
  req(input$item)
occ_plot(12)
})
```



Region growth vs. share
=======================================

```{r}
renderPlotly({
  req(input$margin)
  req(input$item)
  plt <- post_mod_region()|>
    group_by(bc_region)|>
    summarize(employment=sum(employment))|>
    mutate(share=employment/sum(employment))|>
    full_join(regional_mod_cagrs())|>
    ggplot(aes(share, 
            mod_cagr, 
            text=paste0("Region: ",
                        bc_region,
                        "\n Growth rate: ",
                        scales::percent(mod_cagr, accuracy=.1),
                        "\n Share: ",
                        scales::percent(share, accuracy=.1)  
                        )))+
    geom_point(alpha=.5)+
    scale_x_continuous(trans="log10", labels = scales::percent)+
    scale_y_continuous(labels=scales::percent)+
    theme_minimal()+ 
    theme(text=element_text(size=20))+
    labs(x="Share",
         y="Forecast 10 year CAGR")
  ggplotly(plt, tooltip = "text")
})
```

Industry growth vs. share
=============================================

```{r}
renderPlotly({
  req(input$margin)
  req(input$item)
  plt <- post_mod_industry()|>
    group_by(lmo_ind_code, lmo_detailed_industry)|>
    summarize(employment=sum(employment))|>
    ungroup()|>
    mutate(share=employment/sum(employment))|>
    full_join(industry_mod_cagrs())|>
    ggplot(aes(share,
               mod_cagr,
               text=paste0(paste(lmo_ind_code, lmo_detailed_industry, sep=": "),
                        "\n Growth rate: ",
                        scales::percent(mod_cagr, accuracy=.1),
                        "\n Share: ",
                        scales::percent(share, accuracy=.01)
                        )))+
    geom_point(alpha=.5)+
    scale_x_continuous(trans="log10", labels = scales::percent)+
    scale_y_continuous(labels=scales::percent)+
    theme_minimal()+
    theme(text=element_text(size=20))+
    labs(x="Share",
         y="Forecast 10 year CAGR")
  ggplotly(plt, tooltip = "text")
})
```

Occupation growth vs. share
=============================================

```{r}
renderPlotly({
  req(input$margin)
  req(input$item)
  plt <- post_mod_occupation()|>
    group_by(noc_5)|>
    summarize(employment=sum(employment, na.rm=TRUE))|>
    mutate(share=employment/sum(employment, na.rm=TRUE))|>
    full_join(noc_descriptions)|>
    full_join(occupation_mod_cagrs())|>
 ggplot(aes(share, 
            mod_cagr,
            text=paste0(noc_5,
                        ": ",
                        class_title,
                        "\n Growth rate: ",
                        scales::percent(mod_cagr, accuracy=.1),
                        "\n Share: ",
                        scales::percent(share, accuracy=.0001)  
                        )))+
    geom_point(alpha=.5)+
    scale_x_continuous(trans="log10", labels=scales::percent)+
    scale_y_continuous(labels=scales::percent)+
    theme_minimal()+
    theme(text=element_text(size=20))+
    labs(x="Share",
         y="Forecast 10 year CAGR")
  ggplotly(plt, tooltip = "text")
})
```




